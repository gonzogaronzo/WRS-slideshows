<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wilson Tile Generator & Slideshow</title>
    <style>
        /* Make the app fill the entire screen */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Hide scrollbars */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #111827;
            color: #D1D5DB;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            box-sizing: border-box;
            text-align: center;
        }
        .ui-container {
            width: 100%;
            max-width: 800px;
            background-color: #1F2937;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            flex-shrink: 0; /* Prevent UI from shrinking too much */
            transition: all 0.3s ease;
        }
        textarea {
            width: 100%;
            height: 80px;
            padding: 12px;
            font-family: monospace;
            font-size: 1rem;
            background-color: #374151;
            border: 1px solid #4B5563;
            border-radius: 6px;
            color: #F9FAFB;
            box-sizing: border-box;
            resize: vertical;
            margin-bottom: 12px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #F9FAFB;
            background-color: #4B5563;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        button:hover {
            background-color: #6B7280;
        }
        canvas {
            background-color: #1F2937;
            border: 2px dashed #4B5563;
            border-radius: 12px;
            width: 100%;
            height: 100%;
            cursor: grab;
            touch-action: none;
            transition: border 0.3s ease;
        }
        /* Styles for Presentation Mode */
        .hidden {
            display: none !important;
        }
        body.presentation-mode .ui-container {
            padding: 8px;
            margin-bottom: 8px;
        }
        body.presentation-mode .ui-container h1,
        body.presentation-mode .ui-container p,
        body.presentation-mode .ui-container textarea,
        body.presentation-mode .ui-container #generate-btn,
        body.presentation-mode .ui-container #start-slideshow-btn {
            display: none;
        }
        body.presentation-mode #tileCanvas {
            border: none;
            border-radius: 0;
        }
        #presentation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas unless on a button */
        }
        #presentation-overlay button {
            pointer-events: auto; /* Buttons are clickable */
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2rem;
            background-color: rgba(0,0,0,0.4);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #6B7280;
        }
        #prev-slide-btn { left: 20px; }
        #next-slide-btn { right: 20px; }
        #exit-slideshow-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            top: auto !important;           /* override overlay's `top:50%` */
            left: auto !important;
            transform: none !important;     /* override overlay's translateY(-50%) */
            width: 44px;
            height: 44px;
            font-size: 1.5rem;
            border-radius: 50%;
            padding: 0;
            line-height: 1;
            z-index: 11;                    /* ensure above canvas/arrows if needed */
        }

        /* Legend modal */
        #legend-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }
        #legend-card {
            background: #1F2937;
            color: #E5E7EB;
            width: min(720px, 92vw);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            padding: 20px;
            text-align: left;
            border: 1px solid #374151;
        }
        #legend-card h2 { margin: 0 0 8px 0; color: #F9FAFB; }
        #legend-card code {
            background: #111827;
            padding: 2px 6px;
            border-radius: 6px;
        }
        #legend-close {
            float: right;
            background: #374151;
            border: 1px solid #4B5563;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
        }
        #legend-list {
            margin: 12px 0 0 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    
    <div class="ui-container">
        <h1>Wilson Tile Generator</h1>
        <p>Use hyphens for affixes (un-). Use | for syllables (|syl).</p>
        <textarea id="word-input" placeholder="Example:
un- pack -ing
|syl |la |ble
super"></textarea>
        <div class="button-group">
            <button id="generate-btn">Generate Tiles</button>
            <button id="draw-mode-btn">Toggle Draw</button>
            <button id="clear-drawings-btn">Clear Drawings</button>
            <button id="start-slideshow-btn">Start Slideshow</button>
            <button id="download-all-btn">Download All PNGs</button>
            <button id="save-project-btn">Save Show (.wrs.json)</button>
            <button id="open-project-btn">Open Show</button>
            <button id="export-html-btn">Export Self‑Contained HTML</button>
            <button id="legend-btn">Overrides Legend</button>
            <input id="open-project-file" type="file" accept=".json,.wrs.json" style="display:none">
        </div>
    </div>

    <canvas id="tileCanvas"></canvas>

    <div id="presentation-overlay" class="hidden">
        <button id="prev-slide-btn">&#8249;</button>
        <button id="next-slide-btn">&#8250;</button>
        <button id="exit-slideshow-btn">&times;</button> <!-- Replaced text with "X" symbol -->
    </div>

    <div id="legend-modal" role="dialog" aria-modal="true" aria-labelledby="legend-title">
      <div id="legend-card">
        <button id="legend-close" aria-label="Close legend">Close</button>
        <h2 id="legend-title">Overrides &amp; Formatting Legend</h2>
        <div id="legend-list">
          <p><strong>Force a tile’s type:</strong> <code>[text:type]</code></p>
          <ul>
            <li><code>[ph:digraph]</code> → force digraph</li>
            <li><code>[y:vowel]</code> → treat “y” as a vowel</li>
            <li><code>[ed:suffix]</code> → suffix tile</li>
            <li><code>[ar:r_controlled]</code> → r-controlled vowel</li>
            <li><code>[ank:welded]</code> → welded sound</li>
          </ul>
          <p><strong>Single-tile override (no type):</strong> <code>[ank]</code></p>
          <p><strong>Affixes:</strong> prefix <code>re-</code> &nbsp; suffix <code>-ing</code></p>
          <p><strong>Syllable label:</strong> <code>|syl</code></p>
          <p><strong>Built-in types:</strong> <code>consonant, vowel, digraph, trigraph, welded, r_controlled, vowel_team, prefix, suffix, syllable</code></p>
        </div>
      </div>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('tileCanvas');
        const ctx = canvas.getContext('2d');
        const wordInput = document.getElementById('word-input');
        const uiContainer = document.querySelector('.ui-container');
        const presentationOverlay = document.getElementById('presentation-overlay');

        // --- CONFIGURATION & STATE ---
        const TILE_COLORS = {
            'consonant': '#FFFFF0', 'vowel': '#FDD8B5', 'digraph': '#FFFFF0',
            'trigraph': '#FFFFF0', 'welded': '#059669', 'r_controlled': '#FDD8B5',
            'vowel_team': '#FDD8B5', 'prefix': '#FBBF24', 'suffix': '#FBBF24',
            'syllable': '#9CA3AF',
            'default': '#888888', 'text': '#333333'
        };

        const config = {
            lexicon: {
                prefixes: ["un", "dis", "in", "im", "il", "ir", "mis", "non", "de", "pre", "re", "sub", "super", "trans", "inter", "mid", "fore", "uni", "bi", "tri"],
                suffixes: ["s", "es", "er", "or", "ness", "ment", "tion", "sion", "ist", "ing", "ed", "en", "ize", "ful", "less", "able", "ible", "y", "ly", "ous", "ish", "est"],
                digraphs: ["sh", "ch", "th", "wh", "ck", "ph"], trigraphs: ["tch", "dge"],
                r_controlled: ["ar", "or", "er", "ir", "ur"],
                welded: ["all", "am", "an", "ang", "ing", "ong", "ung", "ank", "ink", "onk", "unk"],
                vowel_team: ["ai", "ay", "ea", "ee", "ey", "ie", "oi", "oy", "oa", "oe", "oo", "ow", "ou", "ue", "ui", "ew", "au", "aw"],
                vowels: ["a", "e", "i", "o", "u"]
            }
        };

        let tiles = [];
        let isDragging = false;
        let selectedTile = null;
        let offsetX = 0;
        let offsetY = 0;
        
        let isDrawModeActive = false;
        let isCurrentlyDrawing = false;
        let editorLines = [];
        let presentationDrawings = {}; // Holds drawings for each slide

        // Slideshow State
        let isInPresentationMode = false;
        let presentationWords = [];
        let currentSlideIndex = 0;

        // --- CORE LOGIC ---
        function generateEditorView() {
            const input = wordInput.value;
            tiles = [];
            const words = input.split(/[\n,]/).map(word => word.trim()).filter(word => word.length > 0);
            let currentY = 20;
            const PADDING = 20;
            words.forEach(word => {
                const graphemeData = tokenizeGraphemes(word);
                // --- updated tile sizing constants ---
                const TILE_WIDTH_STANDARD = 112, TILE_HEIGHT_STANDARD = 96; // wider aspect
                const TILE_WIDTH_AFFIX = Math.round(TILE_WIDTH_STANDARD * 1.6), TILE_HEIGHT_AFFIX = Math.round(TILE_HEIGHT_STANDARD * 1.25);
                const TILE_WIDTH_SYLLABLE = Math.round(TILE_WIDTH_STANDARD * 2.2), TILE_HEIGHT_SYLLABLE = Math.round(TILE_HEIGHT_STANDARD * 2);
                const GAP = 14;
                let totalWidth = 0;
                graphemeData.forEach((gData, index) => {
                    let width;
                    switch (gData.type) {
                        case 'prefix': case 'suffix': width = TILE_WIDTH_AFFIX; break;
                        case 'syllable': width = TILE_WIDTH_SYLLABLE; break;
                        default: width = TILE_WIDTH_STANDARD;
                    }
                    totalWidth += width;
                    if (index < graphemeData.length - 1) { totalWidth += GAP; }
                });
                const availableWidth = Math.max(0, canvas.width - (PADDING * 2));
                const scaleFactor = Math.min(1, availableWidth / totalWidth);
                let currentX = PADDING;
                const maxRowHeight = graphemeData.reduce((max, gData) => {
                    let height;
                    switch (gData.type) {
                        case 'prefix': case 'suffix': height = TILE_HEIGHT_AFFIX; break;
                        case 'syllable': height = TILE_HEIGHT_SYLLABLE; break;
                        default: height = TILE_HEIGHT_STANDARD;
                    }
                    return Math.max(max, height);
                }, TILE_HEIGHT_STANDARD) * scaleFactor;
                graphemeData.forEach(gData => {
                    let tileWidth, tileHeight;
                    switch (gData.type) {
                        case 'prefix': case 'suffix':
                            tileWidth = TILE_WIDTH_AFFIX * scaleFactor;
                            tileHeight = TILE_HEIGHT_AFFIX * scaleFactor;
                            break;
                        case 'syllable':
                            tileWidth = TILE_WIDTH_SYLLABLE * scaleFactor;
                            tileHeight = TILE_HEIGHT_SYLLABLE * scaleFactor;
                            break;
                        default:
                            tileWidth = TILE_WIDTH_STANDARD * scaleFactor;
                            tileHeight = TILE_HEIGHT_STANDARD * scaleFactor;
                    }
                    const tileY = currentY + (maxRowHeight - tileHeight) / 2;
                    const newTile = { ...gData, x: currentX, y: tileY, width: tileWidth, height: tileHeight, scale: scaleFactor };
                    tiles.push(newTile);
                    currentX += tileWidth + GAP;
                });
                currentY += maxRowHeight + GAP;
            });
            render();
        }

        // --- SLIDESHOW LOGIC ---
        function startSlideshow() {
            presentationWords = wordInput.value.split(/[\n,]/).map(word => word.trim()).filter(word => word.length > 0);
            if (presentationWords.length === 0) {
                alert("Please enter some words to start the slideshow.");
                return;
            }
            isInPresentationMode = true;
            presentationDrawings = {}; // Reset drawings for the new show
            currentSlideIndex = 0;
            document.body.classList.add('presentation-mode');
            presentationOverlay.classList.remove('hidden');
            drawCurrentSlide();
        }

        function exitSlideshow() {
            isInPresentationMode = false;
            if (isDrawModeActive) { toggleDrawMode(); } // Turn off draw mode when exiting
            document.body.classList.remove('presentation-mode');
            presentationOverlay.classList.add('hidden');
            generateEditorView(); // Go back to stacked view
        }

        function nextSlide() {
            if (currentSlideIndex < presentationWords.length - 1) {
                currentSlideIndex++;
                drawCurrentSlide();
            }
        }

        function prevSlide() {
            if (currentSlideIndex > 0) {
                currentSlideIndex--;
                drawCurrentSlide();
            }
        }

        function drawCurrentSlide() {
            const word = presentationWords[currentSlideIndex];
            const graphemeData = tokenizeGraphemes(word);
            tiles = []; // Clear previous tiles
            
            // --- updated tile sizing constants ---
            const TILE_WIDTH_STANDARD = 112, TILE_HEIGHT_STANDARD = 96;
            const TILE_WIDTH_AFFIX = Math.round(TILE_WIDTH_STANDARD * 1.6), TILE_HEIGHT_AFFIX = Math.round(TILE_HEIGHT_STANDARD * 1.25);
            const TILE_WIDTH_SYLLABLE = Math.round(TILE_WIDTH_STANDARD * 2.2), TILE_HEIGHT_SYLLABLE = Math.round(TILE_HEIGHT_STANDARD * 2);
            const GAP = 14;
            const PADDING = 20;

            let totalWidth = 0;
            graphemeData.forEach((gData, index) => {
                let width;
                switch (gData.type) {
                    case 'prefix': case 'suffix': width = TILE_WIDTH_AFFIX; break;
                    case 'syllable': width = TILE_WIDTH_SYLLABLE; break;
                    default: width = TILE_WIDTH_STANDARD;
                }
                totalWidth += width;
                if (index < graphemeData.length - 1) { totalWidth += GAP; }
            });

            const availableWidth = Math.max(0, canvas.width - (PADDING * 2));
            const scaleFactor = Math.min(1, availableWidth / totalWidth);
            
            const maxRowHeight = graphemeData.reduce((max, gData) => {
                let height;
                switch (gData.type) {
                    case 'prefix': case 'suffix': height = TILE_HEIGHT_AFFIX; break;
                    case 'syllable': height = TILE_HEIGHT_SYLLABLE; break;
                    default: height = TILE_HEIGHT_STANDARD;
                }
                return Math.max(max, height);
            }, TILE_HEIGHT_STANDARD) * scaleFactor;

            let currentX = (canvas.width - (totalWidth * scaleFactor)) / 2;
            let currentY = (canvas.height - maxRowHeight) / 2;

            graphemeData.forEach(gData => {
                let tileWidth, tileHeight;
                switch (gData.type) {
                    case 'prefix': case 'suffix':
                        tileWidth = TILE_WIDTH_AFFIX * scaleFactor;
                        tileHeight = TILE_HEIGHT_AFFIX * scaleFactor;
                        break;
                    case 'syllable':
                        tileWidth = TILE_WIDTH_SYLLABLE * scaleFactor;
                        tileHeight = TILE_HEIGHT_SYLLABLE * scaleFactor;
                        break;
                    default:
                        tileWidth = TILE_WIDTH_STANDARD * scaleFactor;
                        tileHeight = TILE_HEIGHT_STANDARD * scaleFactor;
                }
                const tileY = currentY + (maxRowHeight - tileHeight) / 2;
                const newTile = { ...gData, x: currentX, y: tileY, width: tileWidth, height: tileHeight, scale: scaleFactor };
                tiles.push(newTile);
                currentX += tileWidth + GAP;
            });

            render();
        }

        // --- DRAWING LOGIC ---
        function drawTile(tile, context) {
            const bgColor = TILE_COLORS[tile.type] || TILE_COLORS['default'];
            const cornerRadius = 8 * (tile.scale || 1);
            context.fillStyle = bgColor;
            context.beginPath();
            context.roundRect(tile.x, tile.y, tile.width, tile.height, [cornerRadius]);
            context.fill();
            context.lineWidth = 2 * (tile.scale || 1);
            if (tile === selectedTile && !isInPresentationMode) {
                context.strokeStyle = '#38BDF8';
                context.lineWidth = 4 * (tile.scale || 1);
            } else {
                context.strokeStyle = '#000000';
            }
            context.beginPath();
            context.roundRect(tile.x, tile.y, tile.width, tile.height, [cornerRadius]);
            context.stroke();
            context.fillStyle = TILE_COLORS.text;
            
            let fontSize;
            switch (tile.type) {
                case 'prefix': case 'suffix': fontSize = 36; break;
                case 'syllable': fontSize = 48; break;
                default: fontSize = 28;
            }
            context.font = `bold ${fontSize * (tile.scale || 1)}px "Noto Sans", sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            const centerX = tile.x + tile.width / 2;
            const centerY = tile.y + tile.height / 2;

            // Make letters ~20% wider (X) and ~10% taller (Y)
            context.save();
            context.translate(centerX, centerY);
            context.scale(1.2, 1.1);
            context.fillText(tile.text, 0, 0);
            context.restore();
        }

        function drawLines(context, linesToDraw) {
            if (!linesToDraw) return;
            context.strokeStyle = '#F87171';
            context.lineWidth = 3;
            context.lineCap = 'round';
            context.lineJoin = 'round';
            linesToDraw.forEach(line => {
                if (line.length < 2) return;
                context.beginPath();
                context.moveTo(line[0].x, line[0].y);
                for (let i = 1; i < line.length; i++) {
                    context.lineTo(line[i].x, line[i].y);
                }
                context.stroke();
            });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (const tile of tiles) {
                drawTile(tile, ctx);
            }
            if (isInPresentationMode) {
                drawLines(ctx, presentationDrawings[currentSlideIndex]);
            } else {
                drawLines(ctx, editorLines);
            }
        }
        
        // --- EVENT HANDLERS ---
        function handleDown(e) {
            e.preventDefault();
            const { x, y } = getEventPos(e);
            if (isDrawModeActive) {
                isCurrentlyDrawing = true;
                if (isInPresentationMode) {
                    if (!presentationDrawings[currentSlideIndex]) {
                        presentationDrawings[currentSlideIndex] = [];
                    }
                    presentationDrawings[currentSlideIndex].push([{ x, y }]);
                } else {
                    editorLines.push([{ x, y }]);
                }
                return;
            }
            if (isInPresentationMode) return; // Disable dragging in presentation mode
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                if (x > tile.x && x < tile.x + tile.width && y > tile.y && y < tile.y + tile.height) {
                    selectedTile = tile; isDragging = true; canvas.style.cursor = 'grabbing';
                    offsetX = x - tile.x; offsetY = y - tile.y;
                    tiles.push(tiles.splice(i, 1)[0]); render(); return;
                }
            }
        }
        function handleMove(e) {
            e.preventDefault();
            const { x, y } = getEventPos(e);
            if (isDrawModeActive && isCurrentlyDrawing) {
                if (isInPresentationMode) {
                    const currentLines = presentationDrawings[currentSlideIndex];
                    if (currentLines) currentLines[currentLines.length - 1].push({ x, y });
                } else {
                    editorLines[editorLines.length - 1].push({ x, y });
                }
                render();
                return;
            }
            if (isDragging) { // Already implies not in presentation mode
                selectedTile.x = x - offsetX;
                selectedTile.y = y - offsetY;
                render();
            }
        }
        function handleUp(e) {
            e.preventDefault();
            isCurrentlyDrawing = false;
            if (isDragging) {
                canvas.style.cursor = 'grab'; isDragging = false; selectedTile = null; render();
            }
        }
        function toggleDrawMode() {
            isDrawModeActive = !isDrawModeActive;
            const drawBtn = document.getElementById('draw-mode-btn');
            if (isDrawModeActive) {
                drawBtn.style.backgroundColor = '#059669'; drawBtn.textContent = 'Draw Mode: ON';
                canvas.style.cursor = 'crosshair';
            } else {
                drawBtn.style.backgroundColor = '#4B5563'; drawBtn.textContent = 'Toggle Draw';
                canvas.style.cursor = isInPresentationMode ? 'default' : 'grab';
            }
        }
        function clearDrawings() {
            if (isInPresentationMode) {
                presentationDrawings[currentSlideIndex] = [];
            } else {
                editorLines = [];
            }
            render();
        }

        function handleKeyDown(e) {
            if (!isInPresentationMode) return;
            if (e.key === 'ArrowRight') nextSlide();
            else if (e.key === 'ArrowLeft') prevSlide();
            else if (e.key === 'Escape') exitSlideshow();
        }

        // --- EXPORT HELPERS (self-contained; no external libs) ---
        function generateImageForWord(word) {
            return new Promise(resolve => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const PADDING = 20;
                // updated sizing constants
                const W = 112, H = 96, GAP = 14;
                const TILE_WIDTH_AFFIX = Math.round(W * 1.6), TILE_HEIGHT_AFFIX = Math.round(H * 1.25);
                const TILE_WIDTH_SYLLABLE = Math.round(W * 2.2), TILE_HEIGHT_SYLLABLE = Math.round(H * 2);

                const graphemeData = tokenizeGraphemes(word);
                let totalWidth = 0, maxRowHeight = H;
                graphemeData.forEach((gData, index) => {
                    let w = W, h = H;
                    if (gData.type === 'prefix' || gData.type === 'suffix') { w = TILE_WIDTH_AFFIX; h = TILE_HEIGHT_AFFIX; }
                    else if (gData.type === 'syllable') { w = TILE_WIDTH_SYLLABLE; h = TILE_HEIGHT_SYLLABLE; }
                    totalWidth += w;
                    if (index < graphemeData.length - 1) totalWidth += GAP;
                    maxRowHeight = Math.max(maxRowHeight, h);
                });

                const dpr = 2; // export crisp
                tempCanvas.width = (totalWidth + PADDING * 2) * dpr;
                tempCanvas.height = (maxRowHeight + PADDING * 2) * dpr;
                tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                tempCtx.fillStyle = '#1F2937';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                let x = PADDING;
                graphemeData.forEach(gData => {
                    let w = W, h = H;
                    if (gData.type === 'prefix' || gData.type === 'suffix') { w = TILE_WIDTH_AFFIX; h = TILE_HEIGHT_AFFIX; }
                    else if (gData.type === 'syllable') { w = TILE_WIDTH_SYLLABLE; h = TILE_HEIGHT_SYLLABLE; }
                    const tile = { ...gData, x, y: PADDING + (maxRowHeight - h) / 2, width: w, height: h, scale: 1 };
                    drawTile(tile, tempCtx);
                    x += w + GAP;
                });

                tempCanvas.toBlob(blob => resolve(blob), 'image/png');
            });
        }

        async function downloadAllPNGs() {
            const words = wordInput.value.split(/[\n,]/).map(w => w.trim()).filter(Boolean);
            if (!words.length) { alert('Add some words first.'); return; }
            for (const word of words) {
                const blob = await generateImageForWord(word);
                const a = document.createElement('a');
                const safe = word.toLowerCase().trim().replace(/[^\w-]+/g, '_').replace(/^_+|_+$/g, '');
                a.href = URL.createObjectURL(blob);
                a.download = `${safe || 'slide'}.png`;
                document.body.appendChild(a);
                a.click();
                a.remove();
            }
        }

        // --- PROJECT SAVE/OPEN (Option 2) ---
        function getWordsArray() {
            return wordInput.value.split(/[\n,]/).map(w => w.trim()).filter(Boolean);
        }
        function getProjectData() {
            return {
                version: 1,
                title: document.title || 'Wilson Tiles Show',
                words: getWordsArray(),
                drawings: presentationDrawings  // per-slide drawings (arrays of point arrays)
            };
        }
        function loadProject(obj) {
            if (!obj || !Array.isArray(obj.words)) { alert('Invalid project file.'); return; }
            wordInput.value = obj.words.join('\n');
            presentationDrawings = obj.drawings && typeof obj.drawings === 'object' ? obj.drawings : {};
            currentSlideIndex = 0;
            if (isInPresentationMode) { drawCurrentSlide(); } else { generateEditorView(); }
        }
        function saveProject() {
            const data = getProjectData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            const safe = (data.title || 'wilson_show').toLowerCase().replace(/[^\w-]+/g,'_').replace(/^_+|_+$/g,'');
            a.href = URL.createObjectURL(blob);
            a.download = `${safe || 'wilson_show'}.wrs.json`;
            a.click();
        }
        function openProjectFromFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                try { loadProject(JSON.parse(reader.result)); }
                catch { alert('Could not read project file.'); }
            };
            reader.readAsText(file);
        }

        // --- EXPORT SELF-CONTAINED HTML ---
        function exportSelfContainedHtml() {
            const data = getProjectData();
            const css = document.querySelector('style').textContent;
            // grab current script content (this file has a single main <script>)
            const mainScript = Array.from(document.querySelectorAll('script')).map(s => s.textContent).join('\n\n');
            const savedTag = `<script>window.SAVED_SHOW = ${JSON.stringify(data)};<\\/script>`;
            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${(data.title || 'Wilson Tile Generator & Slideshow').replace(/</g,'&lt;')}</title>
    <style>${css}</style>
</head>
<body>
    <div class="ui-container">
        <h1>Wilson Tile Generator</h1>
        <p>Use hyphens for affixes (un-). Use | for syllables (|syl).</p>
        <textarea id="word-input"></textarea>
        <div class="button-group">
            <button id="generate-btn">Generate Tiles</button>
            <button id="draw-mode-btn">Toggle Draw</button>
            <button id="clear-drawings-btn">Clear Drawings</button>
            <button id="start-slideshow-btn">Start Slideshow</button>
            <button id="download-all-btn">Download All PNGs</button>
            <button id="save-project-btn">Save Show (.wrs.json)</button>
            <button id="open-project-btn">Open Show</button>
            <button id="export-html-btn">Export Self‑Contained HTML</button>
            <input id="open-project-file" type="file" accept=".json,.wrs.json" style="display:none">
        </div>
    </div>
    <canvas id="tileCanvas"></canvas>
    <div id="presentation-overlay" class="hidden">
        <button id="prev-slide-btn">&#8249;</button>
        <button id="next-slide-btn">&#8250;</button>
        <button id="exit-slideshow-btn">&times;</button>
    </div>
    ${savedTag}
    <script>${mainScript}<\\/script>
    <script>
    // Boot: if SAVED_SHOW present, load it and render immediately
    (function(){
        if (window.SAVED_SHOW) {
            const data = window.SAVED_SHOW;
            document.addEventListener('DOMContentLoaded', function(){
                const ta = document.getElementById('word-input');
                if (ta && Array.isArray(data.words)) ta.value = data.words.join('\\n');
                if (typeof loadProject === 'function') { loadProject(data); }
            });
        }
    })();
    <\\/script>
</body>
</html>`;
            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a');
            const safe = (data.title || 'wilson_show').toLowerCase().replace(/[^\w-]+/g,'_').replace(/^_+|_+$/g,'');
            a.href = URL.createObjectURL(blob);
            a.download = `${safe || 'wilson_show'}.wrs.html`;
            a.click();
        }

        // --- UTILITY FUNCTIONS ---
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Calculate the mouse position relative to the canvas element
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            // Adjust for the scaling between the canvas's display size and its drawing buffer size.
            // This fixes the bug where the drawing appears offset from the cursor.
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: mouseX * scaleX,
                y: mouseY * scaleY
            };
        }

        function tokenizeGraphemes(word) {
            const overrideMatch = word.match(/\[(.*?)\]/);
            if (overrideMatch) {
                // Supports [text] and [text:type]
                const raw = overrideMatch[1].replace(/\+/g, '').trim();
                const parts = raw.split(':').map(s => s.trim());
                const content = parts[0] || '';
                const forced = (parts[1] || '').toLowerCase();
                const allowed = new Set(['consonant','vowel','digraph','trigraph','welded','r_controlled','vowel_team','prefix','suffix','syllable']);
                const isForced = allowed.has(forced);
                const type = isForced ? forced : getGraphemeType(content);
                return [{ text: content, type, forced: isForced }];
            }
            
            const finalTokens = [];
            const parts = word.split(/\s+/).filter(p => p.length > 0);

            parts.forEach(part => {
                if (part.startsWith('|') && part.length > 1) {
                    finalTokens.push({ text: part.substring(1), type: 'syllable' });
                } else if (part.startsWith('-') && part.length > 1) {
                    finalTokens.push({ text: part, type: 'suffix' });
                } else if (part.endsWith('-') && part.length > 1) {
                    finalTokens.push({ text: part, type: 'prefix' });
                } else {
                    let remainingBase = part;
                    let remainingLower = remainingBase.toLowerCase();
                    const patterns = [ ...config.lexicon.welded, ...config.lexicon.trigraphs, ...config.lexicon.digraphs, ...config.lexicon.vowel_team, ...config.lexicon.r_controlled, ...config.lexicon.vowels ].sort((a, b) => b.length - a.length);
                    while (remainingBase.length > 0) {
                        let matched = false;
                        for (const pattern of patterns) {
                            if (remainingLower.startsWith(pattern)) {
                                finalTokens.push({ text: remainingBase.slice(0, pattern.length), type: getGraphemeType(pattern) });
                                remainingBase = remainingBase.slice(pattern.length);
                                remainingLower = remainingLower.slice(pattern.length);
                                matched = true;
                                break;
                            }
                        }
                        if (!matched) {
                            finalTokens.push({ text: remainingBase.charAt(0), type: 'consonant' });
                            remainingBase = remainingBase.slice(1);
                            remainingLower = remainingLower.slice(1);
                        }
                    }
                }
                // After building tokens for this part, adjust single 'y' classification contextually
                adjustYTypes(finalTokens);
            });

            return finalTokens;
        }

        function adjustYTypes(tokens) {
            // Treat single-letter 'y' as a vowel when it does NOT precede a vowel sound,
            // and as a consonant when it does (e.g., 'y' in "yes", "yellow", "yodel").
            // Do not change tokens that were forced via [text:type].
            for (let i = 0; i < tokens.length; i++) {
                const t = tokens[i];
                if (t && !t.forced && typeof t.text === 'string' && t.text.length === 1 && t.text.toLowerCase() === 'y') {
                    // Look ahead to the next token to infer onset vs nucleus
                    const next = tokens[i + 1];
                    const nextText = next && typeof next.text === 'string' ? next.text : '';
                    const nextType = next ? next.type : '';
                    const nextStartsWithVowel = /^[aeiou]/i.test(nextText);
                    const nextIsVowelish = nextType === 'vowel' || nextType === 'vowel_team' || nextType === 'r_controlled' || nextStartsWithVowel;

                    if (nextIsVowelish) {
                        // 'y' before a vowel sound functions as consonant (/y/ as in "yes")
                        t.type = 'consonant';
                    } else {
                        // Word-final or before consonant: acts as vowel (e.g., "cry", "gym", "myth", "rhythm")
                        t.type = 'vowel';
                    }
                }
            }
        }

        function getGraphemeType(grapheme) {
            const g = grapheme.replace(/-/g, '').toLowerCase();
            if (config.lexicon.welded.includes(g)) return 'welded';
            if (config.lexicon.trigraphs.includes(g)) return 'trigraph';
            if (config.lexicon.digraphs.includes(g)) return 'digraph';
            if (config.lexicon.r_controlled.includes(g)) return 'r_controlled';
            if (config.lexicon.vowel_team.includes(g)) return 'vowel_team';
            if (config.lexicon.vowels.includes(g)) return 'vowel';
            return 'consonant';
        }

        // --- INITIALIZATION ---
        function resizeAndDraw() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            if (isInPresentationMode) {
                drawCurrentSlide();
            } else {
                generateEditorView();
            }
        }

        window.onload = function() {
            document.getElementById('generate-btn').addEventListener('click', generateEditorView);
            document.getElementById('draw-mode-btn').addEventListener('click', toggleDrawMode);
            document.getElementById('clear-drawings-btn').addEventListener('click', clearDrawings);
            document.getElementById('start-slideshow-btn').addEventListener('click', startSlideshow);

            document.getElementById('download-all-btn').addEventListener('click', downloadAllPNGs);
            document.getElementById('save-project-btn').addEventListener('click', saveProject);
            document.getElementById('open-project-btn').addEventListener('click', () => document.getElementById('open-project-file').click());
            document.getElementById('open-project-file').addEventListener('change', (e) => {
                const f = e.target.files && e.target.files[0];
                if (f) openProjectFromFile(f);
                e.target.value = ''; // allow reopening the same file
            });
            document.getElementById('export-html-btn').addEventListener('click', exportSelfContainedHtml);

            document.getElementById('prev-slide-btn').addEventListener('click', prevSlide);
            document.getElementById('next-slide-btn').addEventListener('click', nextSlide);
            document.getElementById('exit-slideshow-btn').addEventListener('click', exitSlideshow);

            // Legend modal wiring
            document.getElementById('legend-btn').addEventListener('click', () => {
                const m = document.getElementById('legend-modal');
                m.style.display = 'flex';
            });
            document.getElementById('legend-close').addEventListener('click', () => {
                const m = document.getElementById('legend-modal');
                m.style.display = 'none';
            });
            document.getElementById('legend-modal').addEventListener('click', (e) => {
                if (e.target.id === 'legend-modal') {
                    e.currentTarget.style.display = 'none';
                }
            });

            canvas.addEventListener('mousedown', handleDown);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleUp);
            canvas.addEventListener('mouseout', handleUp);
            canvas.addEventListener('touchstart', handleDown);
            canvas.addEventListener('touchmove', handleMove);
            canvas.addEventListener('touchend', handleUp);
            canvas.addEventListener('touchcancel', handleUp);

            window.addEventListener('keydown', handleKeyDown);

            wordInput.value = "un- pack -ing\n|syl |la |ble\nsuper";

            window.addEventListener('resize', resizeAndDraw);
            resizeAndDraw();
        }
    </script>
</body>
</html>


